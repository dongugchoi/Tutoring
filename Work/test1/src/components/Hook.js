/*
    리액트 훅 정리

    훅 규칙
    1. 같은 훅을 여러번 호출 할 수 있다.

    2. 컴포넌트 최상위에서만 호출할 수 있다.
    ㄴ 반복문, 조건문, 중첩된 함수 내에서 훅을 사용할 수 없다.
    
    3. 훅은 기액트 함수 내에서만 호출 할 수 있다.
    리액트훅은 함수형 컴포넌트에서 호출해야하며, 추가적으로 custom hooks에서 호출 할 수 있다.
    
    4. 비동기 함수는 콜백함수로 사용할 수 없다.(async 키워드가 붙은 함수)

    useState
    컴포넌트의 상태를 관리할 수 있는 훅
    - state를 사용하거나 state를 업데이트할 때 호출
    - const [number, setNumber] = useState(1);
    - setNumber(2);
    number의 초기값은 1이되나 반환된 배열의 두번째 값인 setter 함수를 호출하면 상태 값을 변경할 수 있고,
    상태 값이 변경되면 해당 컴포넌트는 다시 렌더링된다.

    setState호출 => 상태변경 => 리렌더링(변경된 상태값 사용)

    useEffect
    컴포넌트 내의 상태의 변화가 있을 때 이를 감지하여 특정 작업을 해줄 수 있는 훅
        (sideEffect => 컴포넌트가 화면에 렌더링 된 이후에 비동기로 처리되어야 하는 부수적인 효과
        예를 들어 API를 호출하는 경우 데이터를 비동기적으로 가져와야 하는데, 만약 그렇지 않다면 데이터를 가져오는 시간동안 렌더링이 지연될 수 있기 떄문
        -함수에서 함수 안의 내용물만으로 결과값을 만드는 것 외에 다른 행위들
        -함수의 output을 만들기 위해 외부에 값을 사용하는 것
        -외부 변수를 함수 안에서 변경 시키는 것)

        useEffect(()=>{ }) // 아무것도 전달 x => 기본적으로는 첫 렌더링(마운트)과 그 이후의 모든 업데이트에 대해서 effect를 수행하게된다.
        useEffect(() => {console.log("Component Loaded"); }, []); => 마운트 될 때만 실행
        useEffect(() => {document.title = `You clicked ${count} times`;}, [count]); => count가 바뀔 때만 effect를 재실행

    useRef
    DOM에 직접 접근할때 사용한다.
    ㄴ React는 DOM으로의 직접 접근을 막고 있기 때문에 ref를 통해 접근해야한다.


    useMemo
    원래, 컴포넌트 내의 변수는 리렌더링 시에 다시 정의된다.
    하지만 useMemo를 사용하면, 매 리렌더링 시마다 다시 정의되는 것이 아니라, 특정 값이 변할 때만 정의된다.

    ex)import { useMemo } from 'react';

        function App() {
        const number = 10;

        // 숫자가 바뀌지 않으면 이전 결과를 재사용
        const doubled = useMemo(() => {
            console.log('계산 중...');
            return number * 2;
        }, [number]);

        return <div>{doubled}</div>;
        }

        doubled는 20이 나오고 이후에 number값이 바뀌지 않으면 다시 계산하지 않고 이전 결과 20을 그대로 사용
        지정된 값이 바뀔때만 계산실행 / 값이 바뀌지않으면 이전 결과를 재사용해서 불필요한 계산을 피한다.

        요약
        계산이 반복적으로 실행되지 않아 효율적.
        메모리에서 이전 계산 결과를 저장해두고, 필요할 때만 다시 계산.
        특히 복잡한 계산이나 렌더링 성능이 중요한 경우에 효과적.    
    */